## 题目

某个机器的配置为：CPU 8 cores, MEM 4G, HDD 4T
这个机器上有一个 1T 的无序数据文件，格式为 (key_size: uint64, key: bytes, value_size: uint64, value: bytes)，其中 1B <= key_size <= 1KB，1B <= value_size <= 1MB。

**作业要求**：

设计一个索引结构，使得并发随机地读取每一个 key-value 的代价最小
允许对数据文件做任意预处理，但是预处理的时间计入到整个读取过程的代价里

## 设计思路

### 思路一：全内存哈希索引

内存中建立一个全局哈希结构, 哈希结构中保存value的位置偏移, 该思路需要消耗大量内存，因此对 key-value 平均长度有要求。
key-value 最小平均大小为：1T / (4G / 8byte) > 2kb

全局哈希存在冲突，可以采用链表法解决，但是建立链表需要消耗额外内存，更好的选择是使用 `cuckoo hash` 算法解决冲突

#### 优点
* 读取速度快，只需一次磁盘IO
* 建立索引不需要额外写入数据

#### 缺点
* 受内存大小限制，索引key数量有上限，适合大 Value 场景
* 机器宕机需要重新建立索引

### 思路二：LSM 树(rocksdb)

直接使用 rocksdb 存储数据

#### 优点
* 持久化存储
* 写性能良好

#### 缺点
* 读性能不好
* 写放大严重
* 数据写入 rocksdb 成本较大

适合小 value 场景

### 思路三：B+树

建立B+树进行索引

#### 优点
* 持久存储
* 可以区间查找

#### 缺点
* 数据预处理比较慢
* 读取时间会进行多次磁盘IO

### 思路四：LSM 树索引元数据

数据中存在大量大value时，同时全局哈希索引又放不下索引数据时，可以采用将数据位置信息放入 rocksdb 中解决

## 方案选取

如果数据全是小 value，可以选取思路二；如果是大小 value 混合可选取思路四；如果全是大 value，且数据索引不超过内存，选用思路一

针对本题，为了尽量减小key-value的索引，假设该数据是大value数据场景，采用全局哈希索引，为了实现简单，暂时不处理哈希冲突